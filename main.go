/*
MIT License

Copyright (c) 2019 Janis Viksne

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

package main

/*
go install github.com\jviksne\jvgores

jvgores -src="sample\data" -dst="sample\output.go" -str="*.txt,*.htm?,*.js,*.css" -def=byte -sep=/ -pkg=res
*/

import (
	"bytes"
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"
	"text/template"
)

type FileVars struct {
	Import         string
	Cmd            string // Command used to generate the file
	PackageName    string
	ByteVars       string
	StrConstants   string
	VarByteFiles   string
	VarStrFiles    string
	GetResBytesFn  string
	MustResBytesFn string
	GetResStrFn    string
	MustResStrFn   string
	FindResFn      string
}

type FindResVars struct {
	FnName   string
	StrLoop  string
	ByteLoop string
}

var (
	genVars         bool
	genFns          bool
	fileVars        FileVars
	findResVars     FindResVars
	getResBytesFn   string
	mustResBytesFn  string
	getResStrFn     string
	mustResStrFn    string
	walkDirMode     bool
	src             string
	dst             string
	pathPrefix      string
	bytePatterns    []string
	strPatterns     []string
	defFormat       string
	byteVarPrefix   string
	strConstPrefix  string
	byteVarKeyVal   [][]string                              // list of byte slice variables
	strConstKeyVal  [][]string                              // list of string constants
	byteAssocKeyVal [][]string                              // list of values to be used by byte functions
	strAssocKeyVal  [][]string                              // list of values to be used by string functions
	varToFile       map[string]string = map[string]string{} // all variable or constant names mapped to filenames, used to identify duplicates
	duplfix         bool              = false               // whether to automatically fix duplicate variable names by appending integer suffix
	maxVarSuffix    int               = 100000              // If multiple files have the same name then the largest integer that can be appended to the name to make it unique
	pathSep         string
	silent          bool           = false
	invVarCharRe    *regexp.Regexp = regexp.MustCompile("[^a-zA-Z0-9_]") // regular expression matching an invalid constant character
)

const (
	fileTemplText = `// Code generated by ` + "`{^.Cmd^}`" + `; DO NOT EDIT.
	
package {^.PackageName^}

{^.Import^}{^.ByteVars^}{^.StrConstants^}{^.VarByteFiles^}{^.VarStrFiles^}{^.GetResBytesFn^}{^.MustResBytesFn^}{^.GetResStrFn^}{^.MustResStrFn^}{^.FindResFn^}
`

	byteVarTemplate = `

// File contents as public byte slice variables.
// Byte slices are variables because arrays can not be constants.
var ({^.^}
)`

	strConstTemplate = `

// File contents as public string constants.
const ({^.^}
)`

	varByteFilesTemplate = `

var byteFiles = map[string][]byte{{^.^}}`

	varStrFilesTemplate = `
	
var strFiles = map[string]string{{^.^}}`

	getResBytesFnTemplText = `

// {^.^} returns embedded file contents as a byte slice.
// If the file is not found, nil is returned.
func {^.^}(name string) []byte {
	return byteFiles[name]
}`

	mustResBytesFnTemplText = `
	
// {^.^} returns embedded file contents as a byte slice.
// Panics if the file is not found.
func {^.^}(name string) []byte {
	b := byteFiles[name]
	if b == nil {
		panic(fmt.Sprintf("Byte resource \"%s\" not found.", name))
	}
	return b
}`

	getResStrFnTemplText = `

// {^.^} returns embedded file contents as a string.
// If the file is not found, an empty string is returned
// with the second argument returned as false (true otherwise).
func {^.^}(name string) (string, bool) {
	s, ok := strFiles[name]
	return s, ok
}`

	mustResStrFnTemplText = `

// {^.^} returns embedded file contents as a string.
// Panics if the file is not found.
func {^.^}(name string) string {
	s, ok := strFiles[name]
	if !ok {
		panic(fmt.Sprintf("String resource \"%s\" not found.", name))
	}
	return s
}`

	findResFnTemplText = `

// {^.FnName^} returns a slice of resource
// paths that match a pattern.
// The pattern is matched as a shell
// file pattern. E.g. pattern "/path/to/*.ext"
// matches "/path/to/somefile.ext"
// but will not match "somefile.ext"
// or "/to/somefile.ext".
func {^.FnName^}(pattern string, inclByte bool, inclStr bool) (*[]string, error) {
	var k string

	res := make([]string, 0, 5)
	{^.StrLoop^}{^.ByteLoop^}

	return &res, nil
}`

	byteLoopText = `
	if inclByte {
		for k, _ = range byteFiles {

			match, err := filepath.Match(pattern, k)

			if err != nil {
				return nil, err
			}

			if match {
				res = append(res, k)
			}
		}	
	}`

	strLoopText = `
	if inclStr {
		for k, _ = range strFiles {

			match, err := filepath.Match(pattern, k)

			if err != nil {
				return nil, err
			}

			if match {
				res = append(res, k)
			}
		}	
	}`

	newline = "\r\n"
)

func main() {

	var (
		bytePatternList string
		strPatternList  string
		err             error
		generate        string
	)

	fileVars.Cmd = strings.Join(os.Args, " ")

	flag.StringVar(&src, "src", "", "source path of some directory or a single file, mandatory")

	flag.StringVar(&dst, "dst", "", "path to output file, if omitted the contents will be output to console")

	flag.StringVar(&fileVars.PackageName, "pkg", "main", "package name to be used in the output file, defaults to main")

	flag.StringVar(&generate, "gen", "both", "what to generate: vars => generate only public variables, func => generate only functions, both => generate both (default)")

	flag.StringVar(&getResBytesFn, "getresbytesfn", "GetResBytes", "name of the function for retrieving the contents of a file as a byte slice, defaults to GetResBytes, pass \"nil\" to ommit the function")

	flag.StringVar(&mustResBytesFn, "mustresbytesfn", "MustResBytes", "name of the helper function for retrieving the contents of a file as a byte slice that panics upon the path not found, defaults to MustResBytes, pass \"nil\" to ommit the function")

	flag.StringVar(&getResStrFn, "getresstrfn", "GetResStr", "name of the function for retrieving the string contents of a file, defaults to GetResStr, pass \"nil\" to ommit the function")

	flag.StringVar(&mustResStrFn, "mustresstrfn", "MustResStr", "name of the helper function for retrieving the string contents of a file that panics upon the path not found, defaults to MustResStr, pass \"nil\" to ommit the function")

	flag.StringVar(&findResVars.FnName, "findresfn", "FindRes", "name of the helper function for finding all files that match a path pattern, defaults to FindRes, pass \"nil\" to ommit the function")

	flag.StringVar(&pathPrefix, "prefix", "", "some path prefix to add to the path that is added to public variables as well as passed to GetResStr() and GetResBytes() functions for identifying the files")

	flag.StringVar(&byteVarPrefix, "bcprefix", "", "some prefix to add to the byte slice variables, defaults to \"B_\" if omitted or empty")

	flag.StringVar(&strConstPrefix, "scprefix", "", "some prefix to add to the string constants, defaults to \"S_\" if omitted or empty")

	flag.StringVar(&bytePatternList, "byte", "", "a comma separated list of shell file name patterns to identify files that should be accessible as byte slices")

	flag.StringVar(&strPatternList, "str", "", "a comma separated list of shell file name patterns to identify files that should be available as strings")

	flag.StringVar(&defFormat, "def", "", `default format in case neither "-byte" nor "-str" patterns are matched: byte => byte (default), str => string, both => put in both, skip => skip the file`)

	flag.BoolVar(&duplfix, "duplfix", false, `whether to automatically fix variables whose path get resolved to an identical variable name, false by default as choosing diferent file names would be preferable to avoid mistakes`)

	flag.StringVar(&pathSep, "sep", "", `the path separator to be used within the go program`)

	flag.BoolVar(&silent, "silent", false, `do not print status information upon successful generation of the file`)

	flag.Parse()

	if len(os.Args) <= 1 {
		flag.Usage()
		return
	}

	// Remove quotes if they are present
	src = getUnquoted(src)
	dst = getUnquoted(dst)
	fileVars.PackageName = getUnquoted(fileVars.PackageName)
	generate = getUnquoted(generate)
	getResBytesFn = getUnquoted(getResBytesFn)
	mustResBytesFn = getUnquoted(mustResBytesFn)
	getResStrFn = getUnquoted(getResStrFn)
	mustResStrFn = getUnquoted(mustResStrFn)
	findResVars.FnName = getUnquoted(findResVars.FnName)
	pathPrefix = getUnquoted(pathPrefix)
	byteVarPrefix = getUnquoted(byteVarPrefix)
	strConstPrefix = getUnquoted(strConstPrefix)
	bytePatternList = getUnquoted(bytePatternList)
	strPatternList = getUnquoted(strPatternList)
	defFormat = getUnquoted(defFormat)
	pathSep = getUnquoted(pathSep)

	if src == "" {
		log.Fatal("Please specify the source directory or file by passing -src=\"some_path\" argument!")
	}

	src, err = filepath.Abs(src)
	if err != nil {
		log.Fatal("Error resolving source path \"" + src + "\"!")
	}

	if dst == "" { // If no output file is specified, force silent mode to print only the contents of the file
		silent = true
	}

	switch defFormat {
	case "byte":
	case "str":
	case "skip":
	case "":
		defFormat = "byte"
	default:
		log.Fatalf("Bad value specified for argument def: \"%s\".\nAllowed values are \"byte\", \"str\", \"both\", \"skip\".", defFormat)
	}

	if fileVars.PackageName == "" {
		fileVars.PackageName = "main"
	}

	switch generate {
	case "vars":
		genVars = true
	case "func":
		genFns = true
	case "both":
		genVars = true
		genFns = true
	default:
		log.Fatalf("Bad value specified for argument gen: \"%s\".\nAllowed values are \"vars\", \"func\", \"both\".", defFormat)
	}

	if getResBytesFn == "" {
		getResBytesFn = "GetResBytes"
	} else if getResBytesFn == "nil" {
		getResBytesFn = ""
	}

	if mustResBytesFn == "" {
		mustResBytesFn = "MustResBytes"
	} else if mustResBytesFn == "nil" {
		mustResBytesFn = ""
	}

	if getResStrFn == "" {
		getResStrFn = "GetResStr"
	} else if getResStrFn == "nil" {
		getResStrFn = ""
	}

	if mustResStrFn == "" {
		mustResStrFn = "MustResStr"
	} else if mustResStrFn == "nil" {
		mustResStrFn = ""
	}

	if findResVars.FnName == "" {
		findResVars.FnName = "FindRes"
	} else if findResVars.FnName == "nil" {
		findResVars.FnName = ""
	}

	// Do not allow blank variabe prefixes
	if byteVarPrefix == "" {
		byteVarPrefix = "B_"
	}

	// Verify that prefix is valid
	if invVarCharRe.MatchString(byteVarPrefix) {
		log.Fatal("The bcprefix contains one or more invalid characters, only Latin letters and numbers are allowed!")
	}

	// Do not allow blank constant prefixes
	if strConstPrefix == "" {
		strConstPrefix = "S_"
	}

	// Verify that prefix is valid
	if invVarCharRe.MatchString(strConstPrefix) {
		log.Fatal("The scprefix contains one or more invalid characters, only Latin letters and numbers are allowed!")
	}

	if bytePatternList != "" {
		bytePatterns = strings.Split(bytePatternList, ",")
	}

	if strPatternList != "" {
		strPatterns = strings.Split(strPatternList, ",")
	}

	if pathSep != "" && pathSep == string(filepath.Separator) {
		pathSep = "" // do not replace the path separator if it already matches the current OS path separator
	}

	byteAssocKeyVal = make([][]string, 0, 25)

	strAssocKeyVal = make([][]string, 0, 25)

	fileT, err := template.New("file").Delims("{^", "^}").Parse(fileTemplText)
	if err != nil {
		log.Fatalf("Error parsing file template: %s", err.Error())
	}

	byteVarT, err := template.New("bytevar").Delims("{^", "^}").Parse(byteVarTemplate)
	if err != nil {
		log.Fatalf("Error parsing \"var(...)\" template: %s", err.Error())
	}

	strConstT, err := template.New("strconst").Delims("{^", "^}").Parse(strConstTemplate)
	if err != nil {
		log.Fatalf("Error parsing \"const(...)\" template: %s", err.Error())
	}

	varByteFilesT, err := template.New("varbytefiles").Delims("{^", "^}").Parse(varByteFilesTemplate)
	if err != nil {
		log.Fatalf("Error parsing \"var byteFiles...\" template: %s", err.Error())
	}

	varStrFilesT, err := template.New("varstrfiles").Delims("{^", "^}").Parse(varStrFilesTemplate)
	if err != nil {
		log.Fatalf("Error parsing \"var strFiles...\" template: %s", err.Error())
	}

	getByteFnT, err := template.New("getresbytes").Delims("{^", "^}").Parse(getResBytesFnTemplText)
	if err != nil {
		log.Fatalf("Error parsing GetResBytes() function template: %s", err.Error())
	}

	mustByteFnT, err := template.New("mustresbytes").Delims("{^", "^}").Parse(mustResBytesFnTemplText)
	if err != nil {
		log.Fatalf("Error parsing MustResBytes() function template: %s", err.Error())
	}

	getStrFnT, err := template.New("getresstr").Delims("{^", "^}").Parse(getResStrFnTemplText)
	if err != nil {
		log.Fatalf("Error parsing GetResStr() template: %s", err.Error())
	}

	mustStrFnT, err := template.New("mustresstr").Delims("{^", "^}").Parse(mustResStrFnTemplText)
	if err != nil {
		log.Fatalf("Error parsing MustResStr() template: %s", err.Error())
	}

	findResFnT, err := template.New("findres").Delims("{^", "^}").Parse(findResFnTemplText)
	if err != nil {
		log.Fatalf("Error parsing FindRes() template: %s", err.Error())
	}

	info, err := os.Stat(src)
	if err != nil {
		log.Fatalf("Error reading source directory or file \"%s\": %s", src, err.Error())
	}

	if info.IsDir() {

		walkDirMode = true

		// append "/" to the source directory to strip it off when
		// creating relativePath in walkFn
		if len(src) > 0 && src[len(src)-1] != os.PathSeparator {
			src = src + string(os.PathSeparator)
		}

		err = filepath.Walk(src, walkFn)
		checkErr(err)

	} else {
		walkDirMode = true
		err = walkFn(src, info, nil)
		checkErr(err)
	}

	// Generate byte variables if there are any
	if genVars && len(byteVarKeyVal) != 0 {
		var tpl bytes.Buffer
		err = byteVarT.Execute(&tpl, getAlignedKeyValStr(byteVarKeyVal, "", " = ", ""))
		if err != nil {
			log.Fatalf("Error executing \"var(...)\" template: %s", err.Error())
		}
		fileVars.ByteVars = tpl.String()
	}

	// Generate string constants if there are any
	if genVars && len(strConstKeyVal) > 0 {
		var tpl bytes.Buffer
		err = strConstT.Execute(&tpl, getAlignedKeyValStr(strConstKeyVal, "", " = ", ""))
		if err != nil {
			log.Fatalf("Error executing \"const(...)\" template: %s", err.Error())
		}
		fileVars.StrConstants = tpl.String()
	}

	if getResBytesFn != "" {
		var tpl bytes.Buffer
		err = getByteFnT.Execute(&tpl, getResBytesFn)
		if err != nil {
			log.Fatalf("Error executing GetResBytes() function template: " + err.Error())
		}
		fileVars.GetResBytesFn = tpl.String()
	}

	if mustResBytesFn != "" {
		var tpl bytes.Buffer
		err = mustByteFnT.Execute(&tpl, mustResBytesFn)
		if err != nil {
			log.Fatalf("Error executing MustResBytes() function template: " + err.Error())
		}
		fileVars.MustResBytesFn = tpl.String()
	}

	// If either of the byte functions is present then init the byte slice map
	if getResBytesFn != "" || mustResBytesFn != "" {
		var tpl bytes.Buffer
		err = varByteFilesT.Execute(&tpl, getAlignedKeyValStr(byteAssocKeyVal, ": ", "", ","))
		if err != nil {
			log.Fatalf("Error executing \"var byteFiles...\" template: %s", err.Error())
		}
		fileVars.VarByteFiles = tpl.String()
	}

	if getResStrFn != "" {
		var tpl bytes.Buffer
		err = getStrFnT.Execute(&tpl, getResStrFn)
		if err != nil {
			log.Fatalf("Error executing GetResStr() function template: %s", err.Error())
		}
		fileVars.GetResStrFn = tpl.String()
	}

	if mustResStrFn != "" {
		var tpl bytes.Buffer
		err = mustStrFnT.Execute(&tpl, mustResStrFn)
		if err != nil {
			log.Fatalf("Error executing MustResStr() function template: %s", err.Error())
		}
		fileVars.MustResStrFn = tpl.String()
	}

	// If either of the byte functions is present then init the string map
	if getResStrFn != "" || mustResStrFn != "" {
		var tpl bytes.Buffer
		err = varStrFilesT.Execute(&tpl, getAlignedKeyValStr(strAssocKeyVal, ": ", "", ","))
		if err != nil {
			log.Fatalf("Error executing \"var strFiles...\" template: %s", err.Error())
		}
		fileVars.VarStrFiles = tpl.String()
	}

	// If FindRes() function is to be constructed and either of the variable
	// maps exists then add the FindRes() function.
	if findResVars.FnName != "" && (fileVars.VarStrFiles != "" || fileVars.VarByteFiles != "") {
		var tpl bytes.Buffer
		findResVars.StrLoop = strLoopText
		findResVars.ByteLoop = byteLoopText
		err = findResFnT.Execute(&tpl, findResVars)
		if err != nil {
			log.Fatalf("Error executing FindRes() function template: %s", err.Error())
		}
		fileVars.FindResFn = tpl.String()
		fileVars.Import = `import (
	"fmt"
	"path/filepath"
)`
	} else {
		fileVars.Import = `import "fmt"`
	}

	// If no destination file is specified, print it to console
	if dst == "" {
		err = fileT.Execute(os.Stdout, fileVars)
	} else {

		f, err := os.Create(dst)
		if err != nil {
			log.Fatalf("Error opening destination file \"%s\" for writing: %s", dst, err.Error())
		}

		defer f.Close()

		err = fileT.Execute(f, fileVars)

		f.Sync()

	}

	if !silent {
		fmt.Println("File successfully created: " + dst)
	}

}

func walkFn(path string, info os.FileInfo, err error) error {

	var (
		isByte       bool   = false // whether to append to byte slice list
		isStr        bool   = false // whether to append to string list
		pathInScript string         //the path that will be used in the script
	)

	// Skip the root dir
	if info.IsDir() && path == src {
		return nil
	}

	// Generate pathInScript from current path
	if walkDirMode { // if we are traversing a directory then strip the starting path only

		// Remove
		if strings.HasPrefix(path, src) {
			pathInScript = pathPrefix + path[len(src):]
		} else {
			pathInScript = pathPrefix + path
		}

	} else { // if we are adding a single file then strip whole path
		pathInScript = pathPrefix + info.Name()
	}

	// If path separator is specified and it does not match the one
	// of current OS then replace it in the pathInScript
	if pathSep != "" && string(filepath.Separator) != pathSep {
		pathInScript = strings.Replace(pathInScript, string(filepath.Separator), pathSep, -1)
	}

	if !silent {
		fmt.Printf("Processing \"%s\": ", pathInScript)
	}

	// If some error occurred print a warning and proceed
	if err != nil {
		if silent {
			if dst != "" { // If not printing to console, then output a warning
				fmt.Println(fmt.Sprintf("File or directory \"%s\" skipped due to an error: %s", pathInScript, err.Error()))
			}
		} else {
			fmt.Println(fmt.Sprintf("skipped due to an error: %s", err.Error()))
		}
		return nil
	}

	// Skip directories
	if info.IsDir() {
		if !silent {
			fmt.Println("directory")
		}
		return nil
	}

	// Match bytePatterns
	if bytePatterns != nil {

		for _, pattern := range bytePatterns {
			matched, err := filepath.Match(pattern, info.Name())

			if err != nil {
				log.Fatalf("Error parsing byte file pattern \"%s\": %s", pattern, err.Error())
			}

			if matched {
				isByte = true
				break
			}
		}

	}

	// Match stringPatterns.
	// Files can be both made available for byte and string format.
	if strPatterns != nil {

		for _, pattern := range strPatterns {
			matched, err := filepath.Match(pattern, info.Name())

			if err != nil {
				log.Fatalf("Error parsing string file pattern \"%s\": %s", pattern, err.Error())
			}

			if matched {
				isStr = true
				break
			}
		}

	}

	// If neither of the patterns is matched,
	// check the default rule.
	if !isByte && !isStr {
		switch defFormat {
		case "byte":
			isByte = true
		case "str":
			isStr = true
		case "both":
			isByte = true
			isStr = true
		}
	}

	if !silent {
		if !isByte && !isStr {
			fmt.Println("skipped (not matching neither byte nor string patterns)")
		} else if isByte && isStr {
			fmt.Println("added to bytes and strings")
		} else if isByte {
			fmt.Println("added to bytes")
		} else if isStr {
			fmt.Println("added to strings")
		}
	}

	// Read the file
	data, err := ioutil.ReadFile(path)

	// If some error occurred print a warning and proceed
	if err != nil {
		if silent {
			if dst != "" { // If not printing to console, then output a warning
				fmt.Println(fmt.Sprintf("WARNING: File \"%s\" skipped due to an error: %s", pathInScript, err.Error()))
			} else { // If printing to console then panic
				log.Fatalf("Error reading file \"%s\": %s", pathInScript, err.Error())
			}
		} else {
			fmt.Println(fmt.Sprintf("skipped due to an error: %s", err.Error()))
		}
		return nil
	}

	// Add to byte constants and variables
	if isByte {

		var b bytes.Buffer

		for i, v := range data {
			if i > 0 {
				b.WriteString(fmt.Sprintf(", %d", v))
			} else {
				b.WriteString(fmt.Sprintf("%d", v))
			}
		}

		if genVars {
			constName := pathToVar(pathInScript, byteVarPrefix)
			byteVarKeyVal = append(byteVarKeyVal, []string{constName, "[]byte{" + b.String() + "}"})
			byteAssocKeyVal = append(byteAssocKeyVal, []string{strconv.Quote(pathInScript), constName})
		} else {
			byteAssocKeyVal = append(byteAssocKeyVal, []string{strconv.Quote(pathInScript), "[]byte{" + b.String() + "}"})
		}

	}

	// Add to string constants and variables
	if isStr {
		if genVars {
			constName := pathToVar(pathInScript, strConstPrefix)
			strConstKeyVal = append(strConstKeyVal, []string{constName, strconv.Quote(string(data))})
			strAssocKeyVal = append(strAssocKeyVal, []string{strconv.Quote(pathInScript), constName})
		} else {
			strAssocKeyVal = append(strAssocKeyVal, []string{strconv.Quote(pathInScript), strconv.Quote(string(data))})
		}
	}

	return nil
}

// getUnquoted returns an unquoted string
// if the string is quoted from both ends,
// and the original string unmodified otherwise.
func getUnquoted(s string) string {

	if len(s) < 2 {
		return s
	}

	if s[0] == s[len(s)-1] && (s[0] == '\'' || s[0] == '"' || s[0] == '`') {
		return s[1 : len(s)-1]
	}

	return s
}

func pathToVar(path string, constPrefix string) string {

	// Generate the name of the variable (or constant)
	c := constPrefix + invVarCharRe.ReplaceAllLiteralString(path, "_")

	// If the name already is used by some path
	otherPath, ok := varToFile[c]
	if ok {

		// Panic if fixing of duplicate names is not enabled
		if !duplfix {
			log.Fatalf("Files \"%s\" and \"%s\" convert into variables with identical name \"%s\".\nPlease either rename one of the files (recommended), or pass -duplfix flag to have an integer appended to the variable names of one of the filenames by random (not recommended).", otherPath, path, c)
		}

		suffix := 1
		for ; suffix < maxVarSuffix; suffix++ {
			otherPath, ok = varToFile[c+string(suffix)]
			if !ok {
				break
			}
		}

		if ok {
			log.Fatalf("Could not generate a unique variable name for file \"%s\".", path)
		}

		c = c + string(suffix)

	}

	return c
}

// getAlignedKeyValStr returns a slice of key value pairs
// concatenated with each pair on a separate row
// and values aligned to start at the same column.
func getAlignedKeyValStr(keyVals [][]string, keySuffix string, valPrefix string, comma string) string {

	count := len(keyVals)

	if count == 0 {
		return ""
	}

	var b bytes.Buffer

	b.WriteString(newline)

	longest := 0

	for _, keyVal := range keyVals {
		if len(keyVal[0]) > longest {
			longest = len(keyVal[0])
		}
	}

	for i, keyVal := range keyVals {

		b.WriteString("\t" + keyVal[0] + keySuffix)

		// If the key is shorter than the longest key
		// then add one or more space between ":" and the value
		// to align all values to start at the same col
		spaces := longest - len(keyVal[0])
		if spaces >= 0 {
			b.WriteString(strings.Repeat(" ", spaces))
		}

		// No comma and newline after the last
		if i == count-1 {
			b.WriteString(valPrefix + keyVal[1])
		} else {
			b.WriteString(valPrefix + keyVal[1] + comma + newline)
		}

	}

	return b.String()

}

func checkErr(err error) {
	if err != nil {
		log.Fatal(err)
	}
}
