# jvgores

jvgores embeds files into a Go file and provides public variables as well as functions for accessing their contents.

It adds all files recursively under a path specified.
The output file provides both public variables and functions for accessing the contents as byte slices or strings.

## Installation

`go install github.com\jviksne\jvgores`

## Usage

From command line:

`jvgores -src="C:\Users\someuser\go\src\github.com\jviksne\jvgores\sample\data" -dst="C:\Users\someuser\go\src\github.com\jviksne\jvgores\sample\output.go" -str="*.txt,*.htm?,*.js,*.css" -def=byte -sep=/ -pkg=res`

Go:generate:

`//go:generate jvgores -src="sample/data" -dst="sample/output.go" -str="*.txt,*.htm?,*.js,*.css" -def=byte -sep=/ -pkg=res`

The flags are:
```
-src="/source/files"
    source path of some directory or a single file, mandatory

-dst="/path/to/some/file.go"
    path to output file, if omitted the contents will be output to console

-pkg="main"
    package name of the output file, defaults to main

-gen=vars|func|both
    what to generate: vars => generate only public variables, func => generate only functions, both => generate both (default)

-getresstrfn="GetResStr"
    name of the function for retrieving the string contents of a file, defaults to GetResStr, pass "nil" to ommit the function

-mustresstrfn="MustResStr"
    name of the helper function for retrieving the string contents of a file that panics upon the path not found, defaults to MustResStr, pass "nil" to ommit the function

-getresbytesfn="GetResBytes"
    name of the function for retrieving the contents of a file as a byte slice, defaults to GetResBytes, pass "nil" to ommit the function

-mustresbytesfn="MustResBytes"
    name of the helper function for retrieving the contents of a file as a byte slice that panics upon the path not found, defaults to MustResBytes, pass "nil" to ommit the function

-findresfn="FindRes"
	name of the helper function for finding all files that match a path pattern, defaults to FindRes, pass "nil" to ommit the function

-prefix="/some/prefix/"
    some path prefix to add to the path that is added to public variables as well as passed to GetResStr() and GetResBytes() functions for identifying the files

-bcprefix="B_"
    some prefix to add to the byte slice variables, defaults to \"B_\" if omitted or empty

-scprefix="S_"
    some prefix to add to the string constants, defaults to \"S_\" if omitted or empty

-byte="*.png,*.jp?g"
    a comma separated list of shell file name patterns to identify files that should be accessible as byte slices

-str="*.htm?,*.css,*.js,*.txt"
    a comma separated list of shell file name patterns to identify files that should be available as strings

-def=byte|str|both|skip
    default format in case neither "-byte" nor "-str" patterns are matched: byte => byte (default), str => string, both => put in both, skip => skip the file

-duplfix
	whether to automatically fix variables whose path get resolved to an identical variable name, false by default as choosing diferent file names would be preferable to avoid mistakes

-sep="/"
    the path separator to be used within the go program

-silent
    do not print status information upon successful generation of the file

-help
    prints information about flags
```

## Sample output file

```go
// Code generated by `jvgores -src=sample\data -dst=sample\output.go -str=*.txt,*.htm?,*.js,*.css -def=byte -sep=/ -pkg=res`; DO NOT EDIT.
	
package res

import (
	"fmt"
	"path/filepath"
)

// File contents as public byte slice variables.
// Byte slices are variables because arrays can not be constants.
var (
	B_zero_png = []byte{137, 80, 78, 71, 13, 10, 26, 10, 0, 0, 0, 13, 73, 72, 68, 82, 0, 0, 0, 1, 0, 0, 0, 1, 8, 6, 0, 0, 0, 31, 21, 196, 137, 0, 0, 0, 6, 98, 75, 71, 68, 0, 255, 0, 255, 0, 255, 160, 189, 167, 147, 0, 0, 0, 9, 112, 72, 89, 115, 0, 0, 46, 35, 0, 0, 46, 35, 1, 120, 165, 63, 118, 0, 0, 0, 11, 73, 68, 65, 84, 8, 215, 99, 96, 0, 2, 0, 0, 5, 0, 1, 226, 38, 5, 155, 0, 0, 0, 0, 73, 69, 78, 68, 174, 66, 96, 130}
)

// File contents as public string constants.
const (
	S_some_text_file_txt                  = "Some text content."
	S_subdir_some_text_file_in_subdir_txt = "First line.\r\nSecond line.\r\nVarious 'quotes' \"on\" `this` line.\r\n"
)

var byteFiles = map[string][]byte{
	"zero.png": B_zero_png}
	
var strFiles = map[string]string{
	"some-text-file.txt":                  S_some_text_file_txt,
	"subdir/some-text-file-in-subdir.txt": S_subdir_some_text_file_in_subdir_txt}

// GetResBytes returns embedded file contents as a byte slice.
// If the file is not found, nil is returned.
func GetResBytes(name string) []byte {
	return byteFiles[name]
}
	
// MustResBytes returns embedded file contents as a byte slice.
// Panics if the file is not found.
func MustResBytes(name string) []byte {
	b := byteFiles[name]
	if b == nil {
		panic(fmt.Sprintf("Byte resource \"%s\" not found.", name))
	}
	return b
}

// GetResStr returns embedded file contents as a string.
// If the file is not found, an empty string is returned
// with the second argument returned as false (true otherwise).
func GetResStr(name string) (string, bool) {
	s, ok := strFiles[name]
	return s, ok
}

// MustResStr returns embedded file contents as a string.
// Panics if the file is not found.
func MustResStr(name string) string {
	s, ok := strFiles[name]
	if !ok {
		panic(fmt.Sprintf("String resource \"%s\" not found.", name))
	}
	return s
}

// FindRes returns a slice of resource paths that
// match a shell file pattern.
// For example, "/path/to/*.ext" matches "/path/to/somefile.ext"
// but will not match "somefile.ext" or "/to/somefile.ext".
func FindRes(pattern string, inclByte bool, inclStr bool) (*[]string, error) {
	var k string

	res := make([]string, 0, 5)
	
	if inclStr {
		for k, _ = range strFiles {

			match, err := filepath.Match(pattern, k)

			if err != nil {
				return nil, err
			}

			if match {
				res = append(res, k)
			}
		}	
	}
	if inclByte {
		for k, _ = range byteFiles {

			match, err := filepath.Match(pattern, k)

			if err != nil {
				return nil, err
			}

			if match {
				res = append(res, k)
			}
		}	
	}

	return &res, nil
}
```
